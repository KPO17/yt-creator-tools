import requests
import re
import xml.etree.ElementTree as ET
import time
import json
from urllib.parse import unquote

class SubtitleError(Exception):
    pass

def get_subtitles_fallback(video_id, format_type='txt', language='fr'):
    """
    M√©thode directe utilisant l'API YouTube - √âvite les blocages anti-bot
    """
    try:
        print(f"üîç Recherche des sous-titres pour {video_id} en {language}")
        
        # Headers pour sembler √™tre un navigateur normal
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': '*/*',
            'Accept-Language': 'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',
            'Accept-Encoding': 'gzip, deflate, br',
            'Referer': f'https://www.youtube.com/watch?v={video_id}',
            'Origin': 'https://www.youtube.com',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin',
        }

        # Essayer plusieurs formats et langues
        attempts = [
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang={language}",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang={language}&fmt=json3",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang=en",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang=en&fmt=json3",
            f"https://www.youtube.com/api/timedtext?v={video_id}",
        ]
        
        response = None
        used_url = ""
        final_language = language
        
        for url in attempts:
            try:
                print(f"üîÑ Essai avec: {url}")
                response = requests.get(url, headers=headers, timeout=15)
                
                if response.status_code == 200 and response.content.strip():
                    used_url = url
                    print(f"‚úÖ Succ√®s avec: {url}")
                    
                    # D√©terminer la langue utilis√©e
                    if 'lang=' in url:
                        lang_match = re.search(r'lang=([a-z]+)', url)
                        if lang_match:
                            final_language = lang_match.group(1)
                    
                    break
                else:
                    print(f"‚ùå √âchec HTTP {response.status_code}")
                    
                time.sleep(0.5)
                
            except requests.RequestException as e:
                print(f"‚ùå Erreur r√©seau: {e}")
                continue
        
        if not response or response.status_code != 200:
            raise SubtitleError('Aucun sous-titre disponible pour cette vid√©o')

        content = response.text
        
        # D√©terminer le format et parser
        transcript_data = []
        
        if 'json' in used_url or (content.strip().startswith('{') and content.strip().endswith('}')):
            print("üìÑ Format d√©tect√©: JSON")
            transcript_data = parse_json_subtitles(content)
        else:
            print("üìÑ Format d√©tect√©: XML")
            transcript_data = parse_xml_subtitles(content)
        
        if not transcript_data:
            raise SubtitleError('Impossible de parser les sous-titres')

        print(f"üìä {len(transcript_data)} segments de sous-titres trouv√©s")

        # Formater selon le type demand√©
        if format_type == 'txt':
            content_output = format_as_text(transcript_data)
        elif format_type == 'srt':
            content_output = format_as_srt(transcript_data)
        elif format_type == 'vtt':
            content_output = format_as_vtt(transcript_data)
        else:
            content_output = format_as_text(transcript_data)

        return {
            'videoId': video_id,
            'language': final_language,
            'format': format_type,
            'content': content_output,
            'lineCount': len(transcript_data),
            'isAutoGenerated': True,
            'method': 'direct_api'
        }
        
    except requests.RequestException as e:
        raise SubtitleError(f'Erreur r√©seau: {str(e)}')
    except Exception as e:
        raise SubtitleError(f'Erreur inattendue: {str(e)}')

def parse_xml_subtitles(xml_content):
    """Parse le format XML des sous-titres YouTube"""
    try:
        xml_content = xml_content.strip()
        root = ET.fromstring(xml_content)
        transcript = []
        
        for element in root.findall('.//text'):
            text = element.text or ''
            start = float(element.get('start', 0))
            dur = float(element.get('dur', 0))
            
            text = clean_text(text)
            
            if text and text.strip():
                transcript.append({
                    'text': text.strip(),
                    'start': start,
                    'duration': dur
                })
        
        return transcript
        
    except Exception as e:
        print(f"‚ùå Erreur parsing XML: {e}")
        return []

def parse_json_subtitles(json_content):
    """Parse le format JSON des sous-titres YouTube"""
    try:
        data = json.loads(json_content)
        transcript = []
        
        events = data.get('events', [])
        for event in events:
            if 'segs' in event:
                start = event.get('tStartMs', 0) / 1000.0
                duration = event.get('dDurationMs', 0) / 1000.0
                
                text_parts = []
                for seg in event['segs']:
                    if 'utf8' in seg:
                        text_parts.append(seg['utf8'])
                
                text = clean_text(''.join(text_parts))
                if text and text.strip():
                    transcript.append({
                        'text': text.strip(),
                        'start': start,
                        'duration': duration
                    })
        
        return transcript
        
    except Exception as e:
        print(f"‚ùå Erreur parsing JSON: {e}")
        return []

def clean_text(text):
    """Nettoie le texte des sous-titres"""
    if not text:
        return ""
    
    text = unquote(text)
    text = re.sub(r'<[^>]+>', '', text)
    
    replacements = {
        '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', 
        '&#39;': "'", '&nbsp;': ' ', '&eacute;': '√©', '&egrave;': '√®'
    }
    
    for entity, replacement in replacements.items():
        text = text.replace(entity, replacement)
    
    text = re.sub(r'\s+', ' ', text)
    return text.strip()

def format_as_text(transcript_data):
    """Formate en texte brut"""
    if not transcript_data:
        return "Aucun sous-titre disponible."
    
    text_parts = []
    for entry in transcript_data:
        text = entry['text']
        if text:
            text_parts.append(text)
    
    return ' '.join(text_parts)

def format_as_srt(transcript_data):
    """Formate en SRT"""
    if not transcript_data:
        return "1\n00:00:00,000 --> 00:00:00,000\nAucun sous-titre disponible"
    
    srt_content = []
    
    for i, entry in enumerate(transcript_data, start=1):
        start_time = format_timestamp_srt(entry['start'])
        end_time = format_timestamp_srt(entry['start'] + entry['duration'])
        text = entry['text']
        
        srt_content.append(f"{i}")
        srt_content.append(f"{start_time} --> {end_time}")
        srt_content.append(text)
        srt_content.append("")
    
    return '\n'.join(srt_content)

def format_as_vtt(transcript_data):
    """Formate en WebVTT"""
    if not transcript_data:
        return "WEBVTT\n\n00:00:00.000 --> 00:00:00.000\nAucun sous-titre disponible"
    
    vtt_content = ["WEBVTT", ""]
    
    for entry in transcript_data:
        start_time = format_timestamp_vtt(entry['start'])
        end_time = format_timestamp_vtt(entry['start'] + entry['duration'])
        text = entry['text']
        
        vtt_content.append(f"{start_time} --> {end_time}")
        vtt_content.append(text)
        vtt_content.append("")
    
    return '\n'.join(vtt_content)

def format_timestamp_srt(seconds):
    """Format SRT : HH:MM:SS,mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

def format_timestamp_vtt(seconds):
    """Format VTT : HH:MM:SS.mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"