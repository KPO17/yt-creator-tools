import requests
import re
import xml.etree.ElementTree as ET
import time

class SubtitleError(Exception):
    pass

def get_subtitles_fallback(video_id, format_type='txt', language='fr'):
    """
    Méthode directe utilisant l'API YouTube - Évite les blocages anti-bot
    """
    try:
        # Headers pour sembler être un navigateur normal
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': '*/*',
            'Accept-Language': 'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',
            'Accept-Encoding': 'gzip, deflate, br',
            'Referer': f'https://www.youtube.com/watch?v={video_id}',
            'Origin': 'https://www.youtube.com',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin',
        }

        # URLs à essayer (par ordre de préférence)
        url_templates = [
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang={language}",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang={language}&fmt=json3",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang=en",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang=fr",
        ]
        
        response = None
        used_url = ""
        
        for url in url_templates:
            try:
                print(f"Essai avec URL: {url}")
                response = requests.get(url, headers=headers, timeout=15)
                if response.status_code == 200 and response.content.strip():
                    used_url = url
                    break
                time.sleep(1)  # Petite pause entre les requêtes
            except requests.RequestException:
                continue
        
        if not response or response.status_code != 200:
            raise SubtitleError('Aucun sous-titre disponible pour cette vidéo')

        # Déterminer le format basé sur l'URL ou le content-type
        content = response.text
        
        if 'json' in used_url or response.headers.get('Content-Type', '').startswith('application/json'):
            transcript_data = parse_json_subtitles(content)
        else:
            transcript_data = parse_xml_subtitles(content)
        
        if not transcript_data:
            raise SubtitleError('Sous-titres vides ou format non supporté')

        # Formater selon le type demandé
        if format_type == 'txt':
            content_output = format_as_text(transcript_data)
        elif format_type == 'srt':
            content_output = format_as_srt(transcript_data)
        elif format_type == 'vtt':
            content_output = format_as_vtt(transcript_data)
        else:
            content_output = format_as_text(transcript_data)

        return {
            'videoId': video_id,
            'language': language,
            'format': format_type,
            'content': content_output,
            'lineCount': len(transcript_data),
            'isAutoGenerated': True,  # Cette méthode ne peut détecter les sous-titres manuels
            'method': 'direct_api'
        }
        
    except requests.RequestException as e:
        raise SubtitleError(f'Erreur réseau: {str(e)}')
    except Exception as e:
        raise SubtitleError(f'Erreur inattendue: {str(e)}')

def parse_xml_subtitles(xml_content):
    """Parse le format XML des sous-titres YouTube"""
    try:
        # Nettoyer le XML si nécessaire
        xml_content = xml_content.strip()
        if not xml_content.startswith('<?xml'):
            xml_content = '<?xml version="1.0" encoding="utf-8"?>' + xml_content
        
        root = ET.fromstring(xml_content)
        transcript = []
        
        for element in root.findall('.//text'):
            text = element.text or ''
            start = float(element.get('start', 0))
            dur = float(element.get('dur', 0))
            
            # Décoder les entités HTML et nettoyer
            text = clean_text(text)
            
            if text and text.strip():
                transcript.append({
                    'text': text.strip(),
                    'start': start,
                    'duration': dur
                })
        
        return transcript
        
    except ET.ParseError as e:
        print(f"Erreur parsing XML: {e}")
        # Essayer de parser comme JSON si XML échoue
        try:
            return parse_json_subtitles(xml_content)
        except:
            return []
    except Exception as e:
        print(f"Erreur inattendue XML: {e}")
        return []

def parse_json_subtitles(json_content):
    """Parse le format JSON des sous-titres YouTube"""
    try:
        data = json.loads(json_content)
        transcript = []
        
        events = data.get('events', [])
        for event in events:
            if 'segs' in event:
                start = event.get('tStartMs', 0) / 1000.0
                duration = event.get('dDurationMs', 0) / 1000.0
                
                text_parts = []
                for seg in event['segs']:
                    if 'utf8' in seg:
                        text_parts.append(seg['utf8'])
                
                text = clean_text(''.join(text_parts))
                if text and text.strip():
                    transcript.append({
                        'text': text.strip(),
                        'start': start,
                        'duration': duration
                    })
        
        return transcript
        
    except json.JSONDecodeError:
        return []
    except Exception as e:
        print(f"Erreur parsing JSON: {e}")
        return []

def clean_text(text):
    """Nettoie le texte des sous-titres"""
    if not text:
        return ""
    
    # Supprimer les tags HTML
    text = re.sub(r'<[^>]+>', '', text)
    # Remplacer les entités HTML
    text = re.sub(r'&amp;', '&', text)
    text = re.sub(r'&lt;', '<', text)
    text = re.sub(r'&gt;', '>', text)
    text = re.sub(r'&quot;', '"', text)
    text = re.sub(r'&#39;', "'", text)
    # Supprimer les espaces multiples
    text = re.sub(r'\s+', ' ', text)
    
    return text.strip()

# Fonctions de formatage (identiques à vos fonctions existantes)
def format_as_text(transcript_data):
    """Formate en texte brut"""
    text_parts = []
    
    for entry in transcript_data:
        text = entry['text'].strip()
        if text:
            text_parts.append(text)
    
    full_text = ' '.join(text_parts)
    # Améliorer la ponctuation
    full_text = re.sub(r'([.!?])\s+', r'\1\n\n', full_text)
    full_text = re.sub(r'\s+', ' ', full_text)
    
    return full_text.strip()

def format_as_srt(transcript_data):
    """Formate en SRT"""
    srt_content = []
    
    for i, entry in enumerate(transcript_data, start=1):
        start_time = format_timestamp_srt(entry['start'])
        end_time = format_timestamp_srt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        srt_content.append(f"{i}")
        srt_content.append(f"{start_time} --> {end_time}")
        srt_content.append(text)
        srt_content.append("")
    
    return '\n'.join(srt_content)

def format_as_vtt(transcript_data):
    """Formate en WebVTT"""
    vtt_content = ["WEBVTT", ""]
    
    for entry in transcript_data:
        start_time = format_timestamp_vtt(entry['start'])
        end_time = format_timestamp_vtt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        vtt_content.append(f"{start_time} --> {end_time}")
        vtt_content.append(text)
        vtt_content.append("")
    
    return '\n'.join(vtt_content)

def format_timestamp_srt(seconds):
    """Format SRT : HH:MM:SS,mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

def format_timestamp_vtt(seconds):
    """Format VTT : HH:MM:SS.mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"