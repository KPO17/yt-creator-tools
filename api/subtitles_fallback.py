import requests
import re
import xml.etree.ElementTree as ET
import time
import json

class SubtitleError(Exception):
    pass

def get_subtitles_fallback(video_id, format_type='txt', language='fr'):
    """
    Méthode directe utilisant l'API YouTube - Évite les blocages anti-bot
    """
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': '*/*',
            'Accept-Language': 'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',
            'Referer': f'https://www.youtube.com/watch?v={video_id}',
        }

        # URLs à essayer
        url_templates = [
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang={language}",
            f"https://www.youtube.com/api/timedtext?v={video_id}&lang=en",
            f"https://www.youtube.com/api/timedtext?v={video_id}",
        ]
        
        response = None
        
        for url in url_templates:
            try:
                print(f"Trying URL: {url}")
                response = requests.get(url, headers=headers, timeout=15)
                if response.status_code == 200 and response.content.strip():
                    break
                time.sleep(1)
            except requests.RequestException:
                continue
        
        if not response or response.status_code != 200:
            raise SubtitleError('Aucun sous-titre disponible pour cette vidéo')

        content = response.text
        
        # Essayer XML d'abord, puis JSON
        try:
            transcript_data = parse_xml_subtitles(content)
        except:
            try:
                transcript_data = parse_json_subtitles(content)
            except:
                transcript_data = []

        if not transcript_data:
            raise SubtitleError('Sous-titres vides ou format non supporté')

        # Formater selon le type demandé
        if format_type == 'txt':
            content_output = format_as_text(transcript_data)
        elif format_type == 'srt':
            content_output = format_as_srt(transcript_data)
        elif format_type == 'vtt':
            content_output = format_as_vtt(transcript_data)
        else:
            content_output = format_as_text(transcript_data)

        return {
            'videoId': video_id,
            'language': language,
            'format': format_type,
            'content': content_output,
            'lineCount': len(transcript_data),
            'isAutoGenerated': True,
            'method': 'direct_api'
        }
        
    except requests.RequestException as e:
        raise SubtitleError(f'Erreur réseau: {str(e)}')
    except Exception as e:
        raise SubtitleError(f'Erreur inattendue: {str(e)}')

def parse_xml_subtitles(xml_content):
    """Parse le format XML des sous-titres YouTube"""
    try:
        # Nettoyer le XML
        xml_content = xml_content.strip()
        
        root = ET.fromstring(xml_content)
        transcript = []
        
        for element in root.findall('.//text'):
            text = element.text or ''
            start = float(element.get('start', 0))
            dur = float(element.get('dur', 0))
            
            # Nettoyer le texte
            text = clean_text(text)
            
            if text and text.strip():
                transcript.append({
                    'text': text.strip(),
                    'start': start,
                    'duration': dur
                })
        
        return transcript
        
    except Exception as e:
        print(f"Erreur parsing XML: {e}")
        return []

def parse_json_subtitles(json_content):
    """Parse le format JSON des sous-titres YouTube"""
    try:
        data = json.loads(json_content)
        transcript = []
        
        events = data.get('events', [])
        for event in events:
            if 'segs' in event:
                start = event.get('tStartMs', 0) / 1000.0
                duration = event.get('dDurationMs', 0) / 1000.0
                
                text_parts = []
                for seg in event['segs']:
                    if 'utf8' in seg:
                        text_parts.append(seg['utf8'])
                
                text = clean_text(''.join(text_parts))
                if text and text.strip():
                    transcript.append({
                        'text': text.strip(),
                        'start': start,
                        'duration': duration
                    })
        
        return transcript
        
    except Exception as e:
        print(f"Erreur parsing JSON: {e}")
        return []

def clean_text(text):
    """Nettoie le texte des sous-titres"""
    if not text:
        return ""
    
    # Supprimer les tags HTML
    text = re.sub(r'<[^>]+>', '', text)
    # Remplacer les entités HTML
    text = re.sub(r'&amp;', '&', text)
    text = re.sub(r'&lt;', '<', text)
    text = re.sub(r'&gt;', '>', text)
    text = re.sub(r'&quot;', '"', text)
    text = re.sub(r'&#39;', "'", text)
    # Supprimer les espaces multiples
    text = re.sub(r'\s+', ' ', text)
    
    return text.strip()

def format_as_text(transcript_data):
    """Formate en texte brut"""
    text_parts = []
    
    for entry in transcript_data:
        text = entry['text'].strip()
        if text:
            text_parts.append(text)
    
    full_text = ' '.join(text_parts)
    full_text = re.sub(r'([.!?])\s+', r'\1\n\n', full_text)
    full_text = re.sub(r'\s+', ' ', full_text)
    
    return full_text.strip()

def format_as_srt(transcript_data):
    """Formate en SRT"""
    srt_content = []
    
    for i, entry in enumerate(transcript_data, start=1):
        start_time = format_timestamp_srt(entry['start'])
        end_time = format_timestamp_srt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        srt_content.append(f"{i}")
        srt_content.append(f"{start_time} --> {end_time}")
        srt_content.append(text)
        srt_content.append("")
    
    return '\n'.join(srt_content)

def format_as_vtt(transcript_data):
    """Formate en WebVTT"""
    vtt_content = ["WEBVTT", ""]
    
    for entry in transcript_data:
        start_time = format_timestamp_vtt(entry['start'])
        end_time = format_timestamp_vtt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        vtt_content.append(f"{start_time} --> {end_time}")
        vtt_content.append(text)
        vtt_content.append("")
    
    return '\n'.join(vtt_content)

def format_timestamp_srt(seconds):
    """Format SRT : HH:MM:SS,mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

def format_timestamp_vtt(seconds):
    """Format VTT : HH:MM:SS.mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"