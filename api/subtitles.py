import requests
import re
import json
import time
from typing import Dict, List, Optional

class SubtitleError(Exception):
    """Exception personnalisée pour les erreurs de sous-titres"""
    pass

def get_subtitles(video_id, format_type='txt', language='fr'):
    """
    Récupère les sous-titres avec fallback sur plusieurs sources
    """
    try:
        print(f"[INFO] Extraction des sous-titres pour {video_id}...")
        
        # Essayer youtube-transcript-api d'abord (sans dépendance externe)
        result = try_youtube_transcript_api(video_id, language)
        
        if result:
            print(f"[INFO] Sous-titres trouvés via youtube-transcript-api")
            transcript_data = result['transcript']
            language_found = result['language']
            is_auto = result.get('is_auto', False)
        else:
            # Fallback sur une API tierce
            print(f"[INFO] Tentative avec API tierce...")
            result = try_external_api(video_id, language)
            
            if not result:
                raise SubtitleError('Aucun sous-titre disponible. YouTube bloque actuellement les accès automatisés.')
            
            transcript_data = result['transcript']
            language_found = result['language']
            is_auto = result.get('is_auto', False)
        
        print(f"[INFO] {len(transcript_data)} lignes trouvées")
        
        # Formater selon le type demandé
        if format_type == 'txt':
            content = format_as_text(transcript_data)
        elif format_type == 'srt':
            content = format_as_srt(transcript_data)
        elif format_type == 'vtt':
            content = format_as_vtt(transcript_data)
        else:
            content = format_as_text(transcript_data)
        
        return {
            'videoId': video_id,
            'language': language_found,
            'format': format_type,
            'content': content,
            'lineCount': len(transcript_data),
            'isAutoGenerated': is_auto
        }
    
    except SubtitleError as e:
        print(f"[ERROR] {str(e)}")
        raise
    
    except Exception as e:
        import traceback
        error_msg = traceback.format_exc()
        print(f"[ERROR] {error_msg}")
        raise SubtitleError(f'Erreur: {type(e).__name__} - {str(e)[:100]}')

def try_youtube_transcript_api(video_id: str, language: str) -> Optional[Dict]:
    """
    Essaye avec youtube-transcript-api (nécessite: pip install youtube-transcript-api)
    """
    try:
        from youtube_transcript_api import YouTubeTranscriptApi
        
        print(f"[INFO] Tentative avec youtube-transcript-api...")
        
        # Lister les langues disponibles
        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
        
        # Chercher la langue demandée
        transcript = None
        lang_found = language
        is_auto = False
        
        # D'abord, chercher les sous-titres manuels
        if language in transcript_list.available_languages:
            transcript = transcript_list.get_transcript([language])
        
        # Sinon, chercher les sous-titres auto-générés
        if not transcript and language in transcript_list.available_languages:
            try:
                transcript = transcript_list.get_transcript([language], continue_on_error=True)
                is_auto = True
            except:
                pass
        
        # Fallback en anglais
        if not transcript:
            try:
                transcript = transcript_list.get_transcript(['en'])
                lang_found = 'en'
            except:
                pass
        
        # Fallback sur n'importe quelle langue
        if not transcript and transcript_list.available_languages:
            transcript = transcript_list.get_transcript([transcript_list.available_languages[0]])
            lang_found = transcript_list.available_languages[0]
        
        if transcript:
            # Convertir au format attendu
            transcript_data = [
                {
                    'text': item['text'],
                    'start': item['start'],
                    'duration': item['duration']
                }
                for item in transcript
            ]
            
            return {
                'transcript': transcript_data,
                'language': lang_found,
                'is_auto': is_auto
            }
    
    except ImportError:
        print("[WARN] youtube-transcript-api non installé, on passe")
        return None
    
    except Exception as e:
        print(f"[WARN] youtube-transcript-api échoué: {e}")
        return None

def try_external_api(video_id: str, language: str) -> Optional[Dict]:
    """
    Essaye avec l'API tierce: https://www.youtube.com/api/timedtext
    """
    try:
        print(f"[INFO] Tentative avec API YouTube timedtext...")
        
        # Récupérer les informations de la vidéo
        info_url = f'https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v={video_id}&format=json'
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        # Vérifier que la vidéo existe
        try:
            info_response = requests.get(info_url, headers=headers, timeout=5)
            if info_response.status_code != 200:
                return None
        except:
            return None
        
        time.sleep(1)
        
        # Essayer d'obtenir les sous-titres via l'API timedtext
        caption_url = f'https://www.youtube.com/api/timedtext?v={video_id}&lang={language}'
        response = requests.get(caption_url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            # Parser le XML des sous-titres
            transcript_data = parse_youtube_captions_xml(response.text)
            
            if transcript_data:
                return {
                    'transcript': transcript_data,
                    'language': language,
                    'is_auto': False
                }
        
        # Fallback en anglais
        if language != 'en':
            caption_url = f'https://www.youtube.com/api/timedtext?v={video_id}&lang=en'
            response = requests.get(caption_url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                transcript_data = parse_youtube_captions_xml(response.text)
                
                if transcript_data:
                    return {
                        'transcript': transcript_data,
                        'language': 'en',
                        'is_auto': False
                    }
        
        return None
    
    except Exception as e:
        print(f"[WARN] API timedtext échouée: {e}")
        return None

def parse_youtube_captions_xml(xml_content: str) -> Optional[List[Dict]]:
    """
    Parse le XML des sous-titres YouTube
    """
    try:
        import xml.etree.ElementTree as ET
        
        transcript_data = []
        root = ET.fromstring(xml_content)
        
        for item in root.findall('.//text'):
            start = float(item.get('start', 0))
            duration = float(item.get('dur', 0))
            text = item.text or ''
            
            if text.strip():
                transcript_data.append({
                    'text': text.strip(),
                    'start': start,
                    'duration': duration
                })
        
        return transcript_data if transcript_data else None
    
    except Exception as e:
        print(f"[ERROR] Erreur parsing XML: {e}")
        return None

def get_available_languages(video_id):
    """Récupère la liste des langues disponibles"""
    try:
        from youtube_transcript_api import YouTubeTranscriptApi
        
        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
        
        languages = []
        
        # Sous-titres manuels
        for lang in transcript_list.available_languages:
            lang_obj = transcript_list._manually_created_transcripts.get(lang)
            if lang_obj:
                languages.append({
                    'code': lang,
                    'name': lang.upper(),
                    'isAutoGenerated': False,
                    'isTranslatable': True
                })
        
        # Sous-titres auto-générés
        for lang in transcript_list.available_languages:
            if lang not in [l['code'] for l in languages]:
                languages.append({
                    'code': lang,
                    'name': f"{lang.upper()} (Auto)",
                    'isAutoGenerated': True,
                    'isTranslatable': True
                })
        
        return languages
    
    except ImportError:
        return []
    except Exception as e:
        raise SubtitleError(f'Erreur: {str(e)}')

def format_as_text(transcript_data):
    """Formate en texte brut"""
    text_parts = []
    
    for entry in transcript_data:
        text = entry['text'].strip()
        text = re.sub(r'\[.*?\]', '', text)
        if text:
            text_parts.append(text)
    
    full_text = ' '.join(text_parts)
    full_text = re.sub(r'([.!?])\s+', r'\1\n\n', full_text)
    
    return full_text.strip()

def format_as_srt(transcript_data):
    """Formate en SRT"""
    srt_content = []
    
    for i, entry in enumerate(transcript_data, start=1):
        start_time = format_timestamp_srt(entry['start'])
        end_time = format_timestamp_srt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        srt_content.append(f"{i}")
        srt_content.append(f"{start_time} --> {end_time}")
        srt_content.append(text)
        srt_content.append("")
    
    return '\n'.join(srt_content)

def format_as_vtt(transcript_data):
    """Formate en WebVTT"""
    vtt_content = ["WEBVTT", ""]
    
    for entry in transcript_data:
        start_time = format_timestamp_vtt(entry['start'])
        end_time = format_timestamp_vtt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        vtt_content.append(f"{start_time} --> {end_time}")
        vtt_content.append(text)
        vtt_content.append("")
    
    return '\n'.join(vtt_content)

def format_timestamp_srt(seconds):
    """Format SRT : HH:MM:SS,mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

def format_timestamp_vtt(seconds):
    """Format VTT : HH:MM:SS.mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"