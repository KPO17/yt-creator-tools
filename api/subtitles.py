from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api._errors import (
    TranscriptsDisabled,
    NoTranscriptFound,
    VideoUnavailable
)
import re

class SubtitleError(Exception):
    """Exception personnalisée pour les erreurs de sous-titres"""
    pass

def get_subtitles(video_id, format_type='txt', language='fr'):
    """
    Récupère les sous-titres via youtube-transcript-api
    Méthode directe sans passer par list_transcripts
    """
    try:
        # MÉTHODE DIRECTE : get_transcript sans list_transcripts
        # Cette méthode évite les erreurs XML de parsing
        
        transcript_data = None
        selected_language = language
        
        # Essayer d'abord la langue demandée
        try:
            transcript_data = YouTubeTranscriptApi.get_transcript(video_id, languages=[language])
            print(f"✓ Sous-titres trouvés en {language}")
        except NoTranscriptFound:
            # Essayer l'anglais
            try:
                transcript_data = YouTubeTranscriptApi.get_transcript(video_id, languages=['en'])
                selected_language = 'en'
                print(f"✓ Sous-titres trouvés en anglais")
            except NoTranscriptFound:
                # Essayer sans spécifier de langue
                try:
                    transcript_data = YouTubeTranscriptApi.get_transcript(video_id)
                    selected_language = 'auto'
                    print(f"✓ Sous-titres trouvés (auto)")
                except Exception:
                    raise SubtitleError('Aucun sous-titre disponible pour cette vidéo')
        
        if not transcript_data:
            raise SubtitleError('Impossible de récupérer les sous-titres')
        
        # Formater selon le type demandé
        if format_type == 'txt':
            content = format_as_text(transcript_data)
        elif format_type == 'srt':
            content = format_as_srt(transcript_data)
        elif format_type == 'vtt':
            content = format_as_vtt(transcript_data)
        else:
            content = format_as_text(transcript_data)
        
        return {
            'videoId': video_id,
            'language': selected_language,
            'format': format_type,
            'content': content,
            'lineCount': len(transcript_data),
            'isAutoGenerated': True  # Assume auto-generated par défaut
        }
    
    except TranscriptsDisabled:
        raise SubtitleError('Les sous-titres sont désactivés pour cette vidéo')
    
    except VideoUnavailable:
        raise SubtitleError('Vidéo non disponible ou privée')
    
    except NoTranscriptFound:
        raise SubtitleError(f'Aucun sous-titre trouvé pour cette vidéo')
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise SubtitleError(f'Erreur : {type(e).__name__} - {str(e)}')

def get_available_languages(video_id):
    """
    Récupère les langues disponibles
    Utilise une méthode simplifiée pour éviter les erreurs
    """
    try:
        # Essayer d'obtenir au moins un transcript pour confirmer qu'il y en a
        YouTubeTranscriptApi.get_transcript(video_id)
        
        # Retourner une liste basique
        return [
            {'code': 'auto', 'name': 'Automatique', 'isAutoGenerated': True, 'isTranslatable': False}
        ]
    except:
        return []

def format_as_text(transcript_data):
    """Formate le transcript en texte brut"""
    text_parts = []
    
    for entry in transcript_data:
        text = entry['text'].strip()
        # Nettoyer les annotations YouTube
        text = re.sub(r'\[.*?\]', '', text)
        text = re.sub(r'\(.*?\)', '', text)
        if text:
            text_parts.append(text)
    
    # Joindre avec des espaces
    full_text = ' '.join(text_parts)
    
    # Ajouter des sauts de ligne après les phrases
    full_text = re.sub(r'([.!?])\s+', r'\1\n\n', full_text)
    
    return full_text.strip()

def format_as_srt(transcript_data):
    """Formate le transcript en SRT (SubRip)"""
    srt_content = []
    
    for i, entry in enumerate(transcript_data, start=1):
        start_time = format_timestamp_srt(entry['start'])
        end_time = format_timestamp_srt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        srt_content.append(f"{i}")
        srt_content.append(f"{start_time} --> {end_time}")
        srt_content.append(text)
        srt_content.append("")
    
    return '\n'.join(srt_content)

def format_as_vtt(transcript_data):
    """Formate le transcript en WebVTT"""
    vtt_content = ["WEBVTT", ""]
    
    for entry in transcript_data:
        start_time = format_timestamp_vtt(entry['start'])
        end_time = format_timestamp_vtt(entry['start'] + entry['duration'])
        text = entry['text'].strip()
        
        vtt_content.append(f"{start_time} --> {end_time}")
        vtt_content.append(text)
        vtt_content.append("")
    
    return '\n'.join(vtt_content)

def format_timestamp_srt(seconds):
    """Format SRT : HH:MM:SS,mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"

def format_timestamp_vtt(seconds):
    """Format VTT : HH:MM:SS.mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"